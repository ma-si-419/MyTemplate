GPU(VRAM)上に作れるバッファの種類
バッファの種類とは書きましたが、実際の処理としては
mallocとかと同じで特定のサイズを確保しているだけです。
じゃあ、どういう風に分かれてるのかというと…

使用用途に合わせて、キャッシュの使い方を適切に選んでくれる
GPU上のキャッシュはちょっと特殊です。

VRAMへのデータはしょせんメモリからコピーしないと
誰も教えてくれない(自分で生成するのはあり)

つまり、メモリ→VRAMの手段があるはず
①双子メモリを用意してメモリとVRAMが一致するような
	仕組みを利用する(キャッシュコヒーレンシ)
②がっつり転送する(DMA転送)…CPUGPUともに暇なときに転送
	してしまう(非同期)


①について
	メリット
		リアルタイムにGPU上の値が書き換えられる(楽ちん)
	デメリット
		低速
	バッファのサイズはそうでもないけど、更新が頻繁に
	行われるものに対して使用される

→定数バッファや頂点バッファ

②について
	メリット
		高速
	デメリット
		CPU側から中身を見ることができない
		→もし見たかったら、DMAと逆の処理を行い
		こちらが見れるバッファ①に転送してもらう。
	バッファのサイズがでかくて、更新がそんなに行われない
	ものに使用される
	→テクスチャバッファ(シェーダーリソース)

今回使用する「定数バッファ」についてですが、基本的に①として生成されるため
	毎フレーム値を変更することができます。
	なお、DirectXだと「定数バッファ(ConstantBuffer)」ですが、OpenGL系だと
	「ユニフォームバッファ(UniformBuffer)」というので注意してください

定数バッファの使い方
①定数バッファとして、VRAM上のメモリを確保する
②双子メモリ(CPU側)のアドレスを取得する(GPU側のメモリアドレスと思っていい)
	void*なので、キャストして使いましょう
	(注)16バイトアライメントになっているため、中途半端なサイズを使うと
	内部的にパディングが発生して、渡したはずのデータがずれておかしなことになる
③②のアドレスをキャストして、中身を書き換えます
④更新関数を呼びます
⑤ピクセルシェーダーにこの定数バッファを背とします
	基本的には、定数バッファは1回セットしたらずっと居座り続けます。
	ところが、DxLibは通常描画の時にも当然ながらシェーダを使っているため
	通常描画をすると、通常描画用の定数バッファで上書きされます
	このため、毎フレームシェーダを使用する場合、シェーダ使用Drawの前に
	定数バッファのセットが必要になります。
	
	
C++の４つのキャスト
static_cast<T>これは一般的な型キャストです。基本はなんにでも使用できます。
				暗黙の型変化が行われるも伸びは確定で使用できる
				・int→float→int (POD型のキャスト)
				・アップキャスト(親の型にキャストする)
				・void 









