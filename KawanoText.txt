GPU(VRAM)上に作れるバッファの種類
バッファの種類とは書きましたが、実際の処理としては
mallocとかと同じで特定のサイズを確保しているだけです。
じゃあ、どういう風に分かれてるのかというと…

使用用途に合わせて、キャッシュの使い方を適切に選んでくれる
GPU上のキャッシュはちょっと特殊です。

VRAMへのデータはしょせんメモリからコピーしないと
誰も教えてくれない(自分で生成するのはあり)

つまり、メモリ→VRAMの手段があるはず
①双子メモリを用意してメモリとVRAMが一致するような
	仕組みを利用する(キャッシュコヒーレンシ)
②がっつり転送する(DMA転送)…CPUGPUともに暇なときに転送
	してしまう(非同期)


①について
	メリット
		リアルタイムにGPU上の値が書き換えられる(楽ちん)
	デメリット
		低速
	バッファのサイズはそうでもないけど、更新が頻繁に
	行われるものに対して使用される

→定数バッファや頂点バッファ

②について
	メリット
		高速
	デメリット
		CPU側から中身を見ることができない
		→もし見たかったら、DMAと逆の処理を行い
		こちらが見れるバッファ①に転送してもらう。
	バッファのサイズがでかくて、更新がそんなに行われない
	ものに使用される
	→テクスチャバッファ(シェーダーリソース)

今回使用する「定数バッファ」についてですが、基本的に①として生成されるため
	毎フレーム値を変更することができます。
	なお、DirectXだと「定数バッファ(ConstantBuffer)」ですが、OpenGL系だと
	「ユニフォームバッファ(UniformBuffer)」というので注意してください

定数バッファの使い方
①定数バッファとして、VRAM上のメモリを確保する
②双子メモリ(CPU側)のアドレスを取得する(GPU側のメモリアドレスと思っていい)
	void*なので、キャストして使いましょう
	(注)16バイトアライメントになっているため、中途半端なサイズを使うと
	内部的にパディングが発生して、渡したはずのデータがずれておかしなことになる
③②のアドレスをキャストして、中身を書き換えます
④更新関数を呼びます
⑤ピクセルシェーダーにこの定数バッファを背とします
	基本的には、定数バッファは1回セットしたらずっと居座り続けます。
	ところが、DxLibは通常描画の時にも当然ながらシェーダを使っているため
	通常描画をすると、通常描画用の定数バッファで上書きされます
	このため、毎フレームシェーダを使用する場合、シェーダ使用Drawの前に
	定数バッファのセットが必要になります。
	
	
C++の４つのキャスト
static_cast<T>これは一般的な型キャストです。基本はなんにでも使用できます。
				暗黙の型変化が行われるも伸びは確定で使用できる
				・int→float→int (POD型のキャスト)
				・アップキャスト(親の型にキャストする)
				・void 
------------------------------------------------------------------
プロシージャルテクスチャを作りたい…
プロシージャルテクスチャとは
実行時にVRAM上に生成されるテクスチャ(計算でシェーダ内で
テクスチャを作りたい)

ところがシェーダ上にはランダム関数がありません
まずこれを作る話をしていきます。

そもそもランダム関数って、どういう仕組みで乱数を
生み出してるの・・・？

ラ分ほとんどの人は
srand(シード)
rand()%n
等で乱数を発生されるところまでしか知らないかな…と
思います。

C言語の乱数生成器は、制度が悪いことが知られています
(証明済み)

「乱数の制度が悪い」ってどういうこと？
乱数とは、次が予測できないのが乱数です。
なので、せいどがわるいとは、次が予測できちゃうということです。
なお、C言語標準乱数で使用されているアルゴリズムは
「線形合同法」というアルゴリズムで生成されています。

線形合同法というのは数列で「前の値を元に作る」
という乱数です。

X[n+1]=(x[n]*A+B)%M

こういう単純な式でできています。このため周期性が問題になる
(次が予測できちゃう)

それに対して、1998年に「メルセンヌツイスタ」というのが
出てきた。これが現代のデファクトスタンダードである。

とはいえこれも前の値から次の値を計算するものである部分んは
線形合同法と同じです。

mt19937 mt;//メルセンヌツイスタ(これも疑似乱数)

random_device rd;//ハードウェアのノイズ情報から乱数を生成
					勝ち乱数ですが、重いため頻繁に使えない。
					
どちらもoperator()オーバーロードを持っており、
使用時は、オブジェクトに対して()を付けて呼び出すと
関数使用のように使える。

乱数に関してもう一つ知っておいてほしいことがあります。
それは範囲についてです。

rand()%10

これって、0～9の乱数を返すことになりますgあ、偏りが発生
します。
どういうことかというと、仮にrand()が16までの乱数を発生
させると仮定します。
0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6

なので、C++では
uniform_int_distribution<T> uid;
uniform_real_ditribution<T> urd;
というのがあります。これは範囲を設定したうえで
その範囲内の乱数を偏りなく提供するものです。

uniform_int_distribution<T>は整数(int,short,unsigned int)
uniform_real_ditribution<T>は実数(浮動小数、倍精度浮動小数)




