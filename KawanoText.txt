GPU(VRAM)上に作れるバッファの種類
バッファの種類とは書きましたが、実際の処理としては
mallocとかと同じで特定のサイズを確保しているだけです。
じゃあ、どういう風に分かれてるのかというと…

使用用途に合わせて、キャッシュの使い方を適切に選んでくれる
GPU上のキャッシュはちょっと特殊です。

VRAMへのデータはしょせんメモリからコピーしないと
誰も教えてくれない(自分で生成するのはあり)

つまり、メモリ→VRAMの手段があるはず
①双子メモリを用意してメモリとVRAMが一致するような
	仕組みを利用する(キャッシュコヒーレンシ)
②がっつり転送する(DMA転送)…CPUGPUともに暇なときに転送
	してしまう(非同期)


①について
	メリット
		リアルタイムにGPU上の値が書き換えられる(楽ちん)
	デメリット
		低速
	バッファのサイズはそうでもないけど、更新が頻繁に
	行われるものに対して使用される

→定数バッファや頂点バッファ

②について
	メリット
		高速
	デメリット
		CPU側から中身を見ることができない
		→もし見たかったら、DMAと逆の処理を行い
		こちらが見れるバッファ①に転送してもらう。
	バッファのサイズがでかくて、更新がそんなに行われない
	ものに使用される
	→テクスチャバッファ(シェーダーリソース)

今回使用する「定数バッファ」についてですが、基本的に①として生成されるため
	毎フレーム値を変更することができます。
	なお、DirectXだと「定数バッファ(ConstantBuffer)」ですが、OpenGL系だと
	「ユニフォームバッファ(UniformBuffer)」というので注意してください

定数バッファの使い方
①定数バッファとして、VRAM上のメモリを確保する
②双子メモリ(CPU側)のアドレスを取得する(GPU側のメモリアドレスと思っていい)
	void*なので、キャストして使いましょう
	(注)16バイトアライメントになっているため、中途半端なサイズを使うと
	内部的にパディングが発生して、渡したはずのデータがずれておかしなことになる
③②のアドレスをキャストして、中身を書き換えます
④更新関数を呼びます
⑤ピクセルシェーダーにこの定数バッファを背とします
	基本的には、定数バッファは1回セットしたらずっと居座り続けます。
	ところが、DxLibは通常描画の時にも当然ながらシェーダを使っているため
	通常描画をすると、通常描画用の定数バッファで上書きされます
	このため、毎フレームシェーダを使用する場合、シェーダ使用Drawの前に
	定数バッファのセットが必要になります。
	
	
C++の４つのキャスト
static_cast<T>これは一般的な型キャストです。基本はなんにでも使用できます。
				暗黙の型変化が行われるも伸びは確定で使用できる
				・int→float→int (POD型のキャスト)
				・アップキャスト(親の型にキャストする)
				・void 
------------------------------------------------------------------
プロシージャルテクスチャを作りたい…
プロシージャルテクスチャとは
実行時にVRAM上に生成されるテクスチャ(計算でシェーダ内で
テクスチャを作りたい)

ところがシェーダ上にはランダム関数がありません
まずこれを作る話をしていきます。

そもそもランダム関数って、どういう仕組みで乱数を
生み出してるの・・・？

ラ分ほとんどの人は
srand(シード)
rand()%n
等で乱数を発生されるところまでしか知らないかな…と
思います。

C言語の乱数生成器は、制度が悪いことが知られています
(証明済み)

「乱数の制度が悪い」ってどういうこと？
乱数とは、次が予測できないのが乱数です。
なので、せいどがわるいとは、次が予測できちゃうということです。
なお、C言語標準乱数で使用されているアルゴリズムは
「線形合同法」というアルゴリズムで生成されています。

線形合同法というのは数列で「前の値を元に作る」
という乱数です。

X[n+1]=(x[n]*A+B)%M

こういう単純な式でできています。このため周期性が問題になる
(次が予測できちゃう)

それに対して、1998年に「メルセンヌツイスタ」というのが
出てきた。これが現代のデファクトスタンダードである。

とはいえこれも前の値から次の値を計算するものである部分んは
線形合同法と同じです。

mt19937 mt;//メルセンヌツイスタ(これも疑似乱数)

random_device rd;//ハードウェアのノイズ情報から乱数を生成
					勝ち乱数ですが、重いため頻繁に使えない。
					
どちらもoperator()オーバーロードを持っており、
使用時は、オブジェクトに対して()を付けて呼び出すと
関数使用のように使える。

乱数に関してもう一つ知っておいてほしいことがあります。
それは範囲についてです。

rand()%10

これって、0～9の乱数を返すことになりますgあ、偏りが発生
します。
どういうことかというと、仮にrand()が16までの乱数を発生
させると仮定します。
0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6

なので、C++では
uniform_int_distribution<T> uid;
uniform_real_ditribution<T> urd;
というのがあります。これは範囲を設定したうえで
その範囲内の乱数を偏りなく提供するものです。

uniform_int_distribution<T>は整数(int,short,unsigned int)
uniform_real_ditribution<T>は実数(浮動小数、倍精度浮動小数)

前回のおさらい
CPU上の乱数
・線形合同法：普通のrand()←乱数の制度が悪い(予想がついてしまう。だいたいの傾向がわかってしまう)
・メルセンヌツイスタ：mt19937クラスを使用する。線形合同法よりはるかに精度が高い
これら2つの乱数生成器は、実は「疑似乱数」である。
直前の値を元に次の「予想しづらい値」を生むものである。
疑似乱数は疑似乱数で利点があります。それはランダムシードが同一のものなら
同一の乱数を生むという点にあります(再現性がある)。これにより、ネットワークゲームを
行うときにお互い同じ環境でプレイすることができます。

ネットワークゲームを作るときは、プレイヤーそれぞれがそれぞれのランダムシード値を
持つのではなく、お互いに同じものを持つ必要があります。このため、ネットワークゲームの
場合は、ゲーム開始時に「親(ルームオーナー等)」が、ランダムシードを決定して
子プレイヤーはそれを使用して、乱数を生成する。これによって乱数環境を統一することができる。

その、ランダムシードをどう作るか、なのですが
以前はGetTickCount()やtimeGetTime()等が使用されていました。
が、最近は、random_deviceが使用されるようになってきました。なぜかというとGetTickCount()は
いわゆるファミコンで言うと、リセットボタンを押してからのミリ秒を返す。このため
ガチのRTAがやるように、起動からの時間で乱数を調整できてしまう。

このため、真の乱数生成器であるrandom_deviceクラスを使用する
random_device rd;
として置いて、rd()とやれば、真の乱数を得ることができる。

この 変数名に()を付けて関数のように呼び出すというやり方はC++ではたまに見かけます。
何なのかというと、これはoperator()()というものを使っています。
一応名前がついていて「Functor」と呼ばれるものです。昨日ではなく、プログラミング言語上の概念です
日本語で言うと「関数オブジェクト」と呼ばれるものです。

class CFunctor{

	private:
	int seed_;
	
	public:
		void operator()(){
			cout<<"Functor"<<endl;
		}
};

なんのためにこんな構造になってるの?関数の遅延実行等に利用したりする。
クロージャ(環境)を利用するためのものです。

基本的にこの手のクラスから生成されたオブジェクトは「関数のようにしか使えません」
メンバ変数等はなく(privateはあるかもしれないが)、()をただ呼び出されるだけの存在





